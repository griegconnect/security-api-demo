/* tslint:disable */
/* eslint-disable */
/**
 * Security
 * Grieg Connects Security API
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApplicationId
 */
export interface ApplicationId {
    /**
     * 
     * @type {string}
     * @memberof ApplicationId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AreaLinkResponse
 */
export interface AreaLinkResponse {
    /**
     * 
     * @type {string}
     * @memberof AreaLinkResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AreaLinkResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface AreaResponse
 */
export interface AreaResponse {
    /**
     * 
     * @type {string}
     * @memberof AreaResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AreaResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AreaResponse
     */
    'securityLevel': number;
    /**
     * 
     * @type {AreaResponseOpeninHours}
     * @memberof AreaResponse
     */
    'openinHours'?: AreaResponseOpeninHours;
    /**
     * 
     * @type {ChecklistsResponse}
     * @memberof AreaResponse
     */
    'checkLists'?: ChecklistsResponse;
    /**
     * 
     * @type {number}
     * @memberof AreaResponse
     */
    'targets'?: number;
    /**
     * 
     * @type {number}
     * @memberof AreaResponse
     */
    'flags': number;
    /**
     * 
     * @type {number}
     * @memberof AreaResponse
     */
    'asset'?: number;
    /**
     * 
     * @type {Array<DocumentResponse>}
     * @memberof AreaResponse
     */
    'files'?: Array<DocumentResponse>;
    /**
     * Arbitrary json object
     * @type {object}
     * @memberof AreaResponse
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface AreaResponseOpeninHours
 */
export interface AreaResponseOpeninHours {
    /**
     * 
     * @type {string}
     * @memberof AreaResponseOpeninHours
     */
    'opening'?: string;
    /**
     * 
     * @type {string}
     * @memberof AreaResponseOpeninHours
     */
    'closing'?: string;
}
/**
 * 
 * @export
 * @interface ChecklistResponse
 */
export interface ChecklistResponse {
    /**
     * 
     * @type {string}
     * @memberof ChecklistResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChecklistResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ChecklistResponse
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof ChecklistResponse
     */
    'minContraolled'?: number;
}
/**
 * 
 * @export
 * @interface ChecklistsResponse
 */
export interface ChecklistsResponse {
    /**
     * 
     * @type {ChecklistResponse}
     * @memberof ChecklistsResponse
     */
    'vehicle'?: ChecklistResponse;
    /**
     * 
     * @type {ChecklistResponse}
     * @memberof ChecklistsResponse
     */
    'person'?: ChecklistResponse;
    /**
     * 
     * @type {ChecklistResponse}
     * @memberof ChecklistsResponse
     */
    'facility'?: ChecklistResponse;
    /**
     * 
     * @type {ChecklistResponse}
     * @memberof ChecklistsResponse
     */
    'quay'?: ChecklistResponse;
    /**
     * 
     * @type {ChecklistResponse}
     * @memberof ChecklistsResponse
     */
    'vessel'?: ChecklistResponse;
}
/**
 * 
 * @export
 * @interface CheckpointLinkResponse
 */
export interface CheckpointLinkResponse {
    /**
     * 
     * @type {string}
     * @memberof CheckpointLinkResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckpointLinkResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CheckpointResponse
 */
export interface CheckpointResponse {
    /**
     * 
     * @type {string}
     * @memberof CheckpointResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CheckpointResponse
     */
    'name': string;
    /**
     * 
     * @type {Array<AreaLinkResponse>}
     * @memberof CheckpointResponse
     */
    'AreaResponse': Array<AreaLinkResponse>;
    /**
     * 
     * @type {string}
     * @memberof CheckpointResponse
     */
    'direction': CheckpointResponseDirectionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CheckpointResponse
     */
    'automaticVehicle': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CheckpointResponse
     */
    'allow': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CheckpointResponse
     */
    'perimeter'?: boolean;
}

export const CheckpointResponseDirectionEnum = {
    None: 'none',
    In: 'in',
    Out: 'out'
} as const;

export type CheckpointResponseDirectionEnum = typeof CheckpointResponseDirectionEnum[keyof typeof CheckpointResponseDirectionEnum];

/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'mediatype'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'filename'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentResponse
     */
    'resolved': boolean;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'mediatype'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface GetApplicationStatus200Response
 */
export interface GetApplicationStatus200Response {
    /**
     * 
     * @type {string}
     * @memberof GetApplicationStatus200Response
     */
    'status'?: GetApplicationStatus200ResponseStatusEnum;
}

export const GetApplicationStatus200ResponseStatusEnum = {
    Submitted: 'submitted',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type GetApplicationStatus200ResponseStatusEnum = typeof GetApplicationStatus200ResponseStatusEnum[keyof typeof GetApplicationStatus200ResponseStatusEnum];

/**
 * 
 * @export
 * @interface IntegrationsResponse
 */
export interface IntegrationsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'salto'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'stanley'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'visy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'westec'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'openpath'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'vehicles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'ava'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'bewator'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IntegrationsResponse
     */
    'stripe'?: boolean;
}
/**
 * Maxiumum allowed duration for the permit, and the default duration used as autofill
 * @export
 * @interface MaxDurationResponse
 */
export interface MaxDurationResponse {
    /**
     * 
     * @type {string}
     * @memberof MaxDurationResponse
     */
    'maxDuration'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaxDurationResponse
     */
    'defaultDuration'?: string;
}
/**
 * 
 * @export
 * @interface MobileLoginRequestRequest
 */
export interface MobileLoginRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof MobileLoginRequestRequest
     */
    'mobile'?: string;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequest
 */
export interface NewVisitorApplicationRequest {
    /**
     * 
     * @type {NewVisitorApplicationRequestVisiting}
     * @memberof NewVisitorApplicationRequest
     */
    'visiting': NewVisitorApplicationRequestVisiting;
    /**
     * 
     * @type {NewVisitorApplicationRequestVisitor}
     * @memberof NewVisitorApplicationRequest
     */
    'visitor': NewVisitorApplicationRequestVisitor;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequest
     */
    'message': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewVisitorApplicationRequest
     */
    'securityConfirmations': Array<string>;
    /**
     * 
     * @type {object}
     * @memberof NewVisitorApplicationRequest
     */
    'integrations': object;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisiting
 */
export interface NewVisitorApplicationRequestVisiting {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'facility': string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'purpose': string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'timeIn'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'timeOut'?: string;
    /**
     * 
     * @type {NewVisitorApplicationRequestVisitingTarget}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'target': NewVisitorApplicationRequestVisitingTarget;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisiting
     */
    'visitHandler'?: string;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitingTarget
 */
export interface NewVisitorApplicationRequestVisitingTarget {
    /**
     * 
     * @type {NewVisitorApplicationRequestVisitingTargetValue}
     * @memberof NewVisitorApplicationRequestVisitingTarget
     */
    'value'?: NewVisitorApplicationRequestVisitingTargetValue;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitingTarget
     */
    'type'?: NewVisitorApplicationRequestVisitingTargetTypeEnum;
}

export const NewVisitorApplicationRequestVisitingTargetTypeEnum = {
    Vessel: 'vessel',
    Company: 'company'
} as const;

export type NewVisitorApplicationRequestVisitingTargetTypeEnum = typeof NewVisitorApplicationRequestVisitingTargetTypeEnum[keyof typeof NewVisitorApplicationRequestVisitingTargetTypeEnum];

/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitingTargetValue
 */
export interface NewVisitorApplicationRequestVisitingTargetValue {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitingTargetValue
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitor
 */
export interface NewVisitorApplicationRequestVisitor {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitor
     */
    'company'?: string;
    /**
     * 
     * @type {NewVisitorApplicationRequestVisitorData}
     * @memberof NewVisitorApplicationRequestVisitor
     */
    'data'?: NewVisitorApplicationRequestVisitorData;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitorData
 */
export interface NewVisitorApplicationRequestVisitorData {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorData
     */
    'mobile': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewVisitorApplicationRequestVisitorData
     */
    'files': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorData
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorData
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorData
     */
    'portraitHref'?: string;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitorDataAnyOf
 */
export interface NewVisitorApplicationRequestVisitorDataAnyOf {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf
     */
    'mobile'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf
     */
    'files': Array<string>;
}
/**
 * 
 * @export
 * @interface NewVisitorApplicationRequestVisitorDataAnyOf1
 */
export interface NewVisitorApplicationRequestVisitorDataAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf1
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf1
     */
    'mobile': string;
    /**
     * 
     * @type {string}
     * @memberof NewVisitorApplicationRequestVisitorDataAnyOf1
     */
    'portraitHref'?: string;
}
/**
 * 
 * @export
 * @interface OrbitaPassingRequest
 */
export interface OrbitaPassingRequest {
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'eventId': string;
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'licensePlate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'readerId': string;
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrbitaPassingRequest
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Passing
 */
export interface Passing {
    /**
     * 
     * @type {PassingDetails}
     * @memberof Passing
     */
    'passing'?: PassingDetails;
    /**
     * 
     * @type {Array<PassingPeopleInner>}
     * @memberof Passing
     */
    'people'?: Array<PassingPeopleInner>;
}
/**
 * 
 * @export
 * @interface PassingDetails
 */
export interface PassingDetails {
    /**
     * 
     * @type {string}
     * @memberof PassingDetails
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PassingDetails
     */
    'pin'?: string;
    /**
     * 
     * @type {string}
     * @memberof PassingDetails
     */
    'createdAt'?: string;
    /**
     * 
     * @type {CheckpointLinkResponse}
     * @memberof PassingDetails
     */
    'checkpoint'?: CheckpointLinkResponse;
    /**
     * 
     * @type {AreaLinkResponse}
     * @memberof PassingDetails
     */
    'facilitiy:'?: AreaLinkResponse;
}
/**
 * 
 * @export
 * @interface PassingPeopleInner
 */
export interface PassingPeopleInner {
    /**
     * 
     * @type {string}
     * @memberof PassingPeopleInner
     */
    'company'?: string;
    /**
     * 
     * @type {Person}
     * @memberof PassingPeopleInner
     */
    'person'?: Person;
}
/**
 * 
 * @export
 * @interface PassingsResponse
 */
export interface PassingsResponse {
    /**
     * 
     * @type {Array<Passing>}
     * @memberof PassingsResponse
     */
    'values'?: Array<Passing>;
    /**
     * 
     * @type {PassingsResponseView}
     * @memberof PassingsResponse
     */
    'view'?: PassingsResponseView;
}
/**
 * 
 * @export
 * @interface PassingsResponseView
 */
export interface PassingsResponseView {
    /**
     * 
     * @type {number}
     * @memberof PassingsResponseView
     */
    'view': number;
    /**
     * 
     * @type {number}
     * @memberof PassingsResponseView
     */
    'next': number;
    /**
     * 
     * @type {number}
     * @memberof PassingsResponseView
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface Person
 */
export interface Person {
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'email_verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Person
     */
    'mobile'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Person
     */
    'mobile_verified'?: boolean;
}
/**
 * 
 * @export
 * @interface PortCompanyResponse
 */
export interface PortCompanyResponse {
    /**
     * 
     * @type {PortCompanyResponseCompany}
     * @memberof PortCompanyResponse
     */
    'company'?: PortCompanyResponseCompany;
    /**
     * 
     * @type {Array<AreaLinkResponse>}
     * @memberof PortCompanyResponse
     */
    'facilities'?: Array<AreaLinkResponse>;
}
/**
 * 
 * @export
 * @interface PortCompanyResponseCompany
 */
export interface PortCompanyResponseCompany {
    /**
     * 
     * @type {string}
     * @memberof PortCompanyResponseCompany
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PortCompanyResponseCompany
     */
    'ref': string;
    /**
     * 
     * @type {string}
     * @memberof PortCompanyResponseCompany
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PortCompanyResponseCompany
     */
    'resolved': boolean;
}
/**
 * 
 * @export
 * @interface PortDetails
 */
export interface PortDetails {
    /**
     * 
     * @type {PortResponse}
     * @memberof PortDetails
     */
    'port'?: PortResponse;
    /**
     * 
     * @type {Array<AreaResponse>}
     * @memberof PortDetails
     */
    'areas'?: Array<AreaResponse>;
    /**
     * 
     * @type {Array<CheckpointResponse>}
     * @memberof PortDetails
     */
    'checkpoint'?: Array<CheckpointResponse>;
    /**
     * 
     * @type {Array<PurposeResponse>}
     * @memberof PortDetails
     */
    'purpose'?: Array<PurposeResponse>;
    /**
     * 
     * @type {Array<PortCompanyResponse>}
     * @memberof PortDetails
     */
    'port_companies'?: Array<PortCompanyResponse>;
    /**
     * 
     * @type {Array<SecurityCheckResultsResponse>}
     * @memberof PortDetails
     */
    'securityCheckResults'?: Array<SecurityCheckResultsResponse>;
    /**
     * 
     * @type {Array<SecurityConfirmationsResponse>}
     * @memberof PortDetails
     */
    'securityConfirmations'?: Array<SecurityConfirmationsResponse>;
    /**
     * 
     * @type {Array<IntegrationsResponse>}
     * @memberof PortDetails
     */
    'integrationsResponse'?: Array<IntegrationsResponse>;
}
/**
 * 
 * @export
 * @interface PortResponse
 */
export interface PortResponse {
    /**
     * 
     * @type {string}
     * @memberof PortResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PortResponse
     */
    'ref': string;
    /**
     * 
     * @type {string}
     * @memberof PortResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PurposeResponse
 */
export interface PurposeResponse {
    /**
     * 
     * @type {string}
     * @memberof PurposeResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PurposeResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PurposeResponse
     */
    'maxDuration'?: string;
    /**
     * Object containing translations, e.g. {en: a translation, no: en oversettelse}
     * @type {{ [key: string]: string; }}
     * @memberof PurposeResponse
     */
    'i18n'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SecurityCheckResultsResponse
 */
export interface SecurityCheckResultsResponse {
    /**
     * 
     * @type {string}
     * @memberof SecurityCheckResultsResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityCheckResultsResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityCheckResultsResponse
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecurityCheckResultsResponse
     */
    'severity'?: number;
}
/**
 * 
 * @export
 * @interface SecurityConfirmationsResponse
 */
export interface SecurityConfirmationsResponse {
    /**
     * 
     * @type {string}
     * @memberof SecurityConfirmationsResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecurityConfirmationsResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SecurityConfirmationsResponse
     */
    'details'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityConfirmationsResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof SecurityConfirmationsResponse
     */
    'deactivatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecurityConfirmationsResponse
     */
    'rank': number;
    /**
     * 
     * @type {DocumentResponse}
     * @memberof SecurityConfirmationsResponse
     */
    'document'?: DocumentResponse;
}
/**
 * 
 * @export
 * @interface VerifyPortIdentityRequest
 */
export interface VerifyPortIdentityRequest {
    /**
     * 
     * @type {string}
     * @memberof VerifyPortIdentityRequest
     */
    'pin'?: string;
}
/**
 * 
 * @export
 * @interface VerifyVehicleResponse
 */
export interface VerifyVehicleResponse {
    /**
     * 
     * @type {boolean}
     * @memberof VerifyVehicleResponse
     */
    'approved'?: boolean;
}

/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new application for a user
         * @summary Create a new application for a user
         * @param {string} portId Id of relevant port
         * @param {NewVisitorApplicationRequest} newVisitorApplicationRequest Payload to create a new application for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication: async (portId: string, newVisitorApplicationRequest: NewVisitorApplicationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('createApplication', 'portId', portId)
            // verify required parameter 'newVisitorApplicationRequest' is not null or undefined
            assertParamExists('createApplication', 'newVisitorApplicationRequest', newVisitorApplicationRequest)
            const localVarPath = `/ports/{portId}/applications2`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newVisitorApplicationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application status
         * @summary Get the status of an application
         * @param {string} portId Id of relevant port
         * @param {string} id Id of the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('getApplicationStatus', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getApplicationStatus', 'id', id)
            const localVarPath = `/ports/{portId}/applications2/{id}/status`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApplicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new application for a user
         * @summary Create a new application for a user
         * @param {string} portId Id of relevant port
         * @param {NewVisitorApplicationRequest} newVisitorApplicationRequest Payload to create a new application for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplication(portId: string, newVisitorApplicationRequest: NewVisitorApplicationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplication(portId, newVisitorApplicationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.createApplication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get application status
         * @summary Get the status of an application
         * @param {string} portId Id of relevant port
         * @param {string} id Id of the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApplicationStatus(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApplicationStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApplicationStatus(portId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApplicationApi.getApplicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApplicationApiFp(configuration)
    return {
        /**
         * Create a new application for a user
         * @summary Create a new application for a user
         * @param {string} portId Id of relevant port
         * @param {NewVisitorApplicationRequest} newVisitorApplicationRequest Payload to create a new application for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplication(portId: string, newVisitorApplicationRequest: NewVisitorApplicationRequest, options?: any): AxiosPromise<ApplicationId> {
            return localVarFp.createApplication(portId, newVisitorApplicationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application status
         * @summary Get the status of an application
         * @param {string} portId Id of relevant port
         * @param {string} id Id of the application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationStatus(portId: string, id: string, options?: any): AxiosPromise<GetApplicationStatus200Response> {
            return localVarFp.getApplicationStatus(portId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * Create a new application for a user
     * @summary Create a new application for a user
     * @param {string} portId Id of relevant port
     * @param {NewVisitorApplicationRequest} newVisitorApplicationRequest Payload to create a new application for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createApplication(portId: string, newVisitorApplicationRequest: NewVisitorApplicationRequest, options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).createApplication(portId, newVisitorApplicationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application status
     * @summary Get the status of an application
     * @param {string} portId Id of relevant port
     * @param {string} id Id of the application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationStatus(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return ApplicationApiFp(this.configuration).getApplicationStatus(portId, id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdentityApi - axios parameter creator
 * @export
 */
export const IdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Issue a request to verify a port identity with a mobile number
         * @summary Issue a request to verify a port identity with a mobile number
         * @param {string} portId Id of relevant port
         * @param {MobileLoginRequestRequest} mobileLoginRequestRequest Payload fto issue a request to verify a port identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueMobileLoginRequest: async (portId: string, mobileLoginRequestRequest: MobileLoginRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('issueMobileLoginRequest', 'portId', portId)
            // verify required parameter 'mobileLoginRequestRequest' is not null or undefined
            assertParamExists('issueMobileLoginRequest', 'mobileLoginRequestRequest', mobileLoginRequestRequest)
            const localVarPath = `/ports/{portId}/identities/mobile/login`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mobileLoginRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify user identity with PIN code sent over SMS
         * @summary Verify user identity with PIN code sent over SMS
         * @param {string} portId Id of relevant port
         * @param {VerifyPortIdentityRequest} verifyPortIdentityRequest Payload for port identity to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMobile: async (portId: string, verifyPortIdentityRequest: VerifyPortIdentityRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('verifyMobile', 'portId', portId)
            // verify required parameter 'verifyPortIdentityRequest' is not null or undefined
            assertParamExists('verifyMobile', 'verifyPortIdentityRequest', verifyPortIdentityRequest)
            const localVarPath = `/ports/{portId}/identities/mobile/verify`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyPortIdentityRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentityApi - functional programming interface
 * @export
 */
export const IdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * Issue a request to verify a port identity with a mobile number
         * @summary Issue a request to verify a port identity with a mobile number
         * @param {string} portId Id of relevant port
         * @param {MobileLoginRequestRequest} mobileLoginRequestRequest Payload fto issue a request to verify a port identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueMobileLoginRequest(portId: string, mobileLoginRequestRequest: MobileLoginRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueMobileLoginRequest(portId, mobileLoginRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.issueMobileLoginRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify user identity with PIN code sent over SMS
         * @summary Verify user identity with PIN code sent over SMS
         * @param {string} portId Id of relevant port
         * @param {VerifyPortIdentityRequest} verifyPortIdentityRequest Payload for port identity to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyMobile(portId: string, verifyPortIdentityRequest: VerifyPortIdentityRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyMobile(portId, verifyPortIdentityRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdentityApi.verifyMobile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdentityApi - factory interface
 * @export
 */
export const IdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentityApiFp(configuration)
    return {
        /**
         * Issue a request to verify a port identity with a mobile number
         * @summary Issue a request to verify a port identity with a mobile number
         * @param {string} portId Id of relevant port
         * @param {MobileLoginRequestRequest} mobileLoginRequestRequest Payload fto issue a request to verify a port identity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueMobileLoginRequest(portId: string, mobileLoginRequestRequest: MobileLoginRequestRequest, options?: any): AxiosPromise<void> {
            return localVarFp.issueMobileLoginRequest(portId, mobileLoginRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify user identity with PIN code sent over SMS
         * @summary Verify user identity with PIN code sent over SMS
         * @param {string} portId Id of relevant port
         * @param {VerifyPortIdentityRequest} verifyPortIdentityRequest Payload for port identity to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyMobile(portId: string, verifyPortIdentityRequest: VerifyPortIdentityRequest, options?: any): AxiosPromise<void> {
            return localVarFp.verifyMobile(portId, verifyPortIdentityRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentityApi - object-oriented interface
 * @export
 * @class IdentityApi
 * @extends {BaseAPI}
 */
export class IdentityApi extends BaseAPI {
    /**
     * Issue a request to verify a port identity with a mobile number
     * @summary Issue a request to verify a port identity with a mobile number
     * @param {string} portId Id of relevant port
     * @param {MobileLoginRequestRequest} mobileLoginRequestRequest Payload fto issue a request to verify a port identity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public issueMobileLoginRequest(portId: string, mobileLoginRequestRequest: MobileLoginRequestRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).issueMobileLoginRequest(portId, mobileLoginRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify user identity with PIN code sent over SMS
     * @summary Verify user identity with PIN code sent over SMS
     * @param {string} portId Id of relevant port
     * @param {VerifyPortIdentityRequest} verifyPortIdentityRequest Payload for port identity to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentityApi
     */
    public verifyMobile(portId: string, verifyPortIdentityRequest: VerifyPortIdentityRequest, options?: RawAxiosRequestConfig) {
        return IdentityApiFp(this.configuration).verifyMobile(portId, verifyPortIdentityRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PassingsApi - axios parameter creator
 * @export
 */
export const PassingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new passing in Orbita
         * @summary Create a new passing in Orbita
         * @param {string} portId Id of relevant port
         * @param {OrbitaPassingRequest} orbitaPassingRequest Payload to create a new passing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPassing: async (portId: string, orbitaPassingRequest: OrbitaPassingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('createPassing', 'portId', portId)
            // verify required parameter 'orbitaPassingRequest' is not null or undefined
            assertParamExists('createPassing', 'orbitaPassingRequest', orbitaPassingRequest)
            const localVarPath = `/ports/{portId}/integrations/orbita/event`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orbitaPassingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Show latest passings
         * @summary Show latest passings
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassings: async (portId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('getPassings', 'portId', portId)
            const localVarPath = `/ports/{portId}/passings`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PassingsApi - functional programming interface
 * @export
 */
export const PassingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PassingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new passing in Orbita
         * @summary Create a new passing in Orbita
         * @param {string} portId Id of relevant port
         * @param {OrbitaPassingRequest} orbitaPassingRequest Payload to create a new passing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPassing(portId: string, orbitaPassingRequest: OrbitaPassingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrbitaPassingRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPassing(portId, orbitaPassingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PassingsApi.createPassing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Show latest passings
         * @summary Show latest passings
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPassings(portId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PassingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPassings(portId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PassingsApi.getPassings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PassingsApi - factory interface
 * @export
 */
export const PassingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PassingsApiFp(configuration)
    return {
        /**
         * Create a new passing in Orbita
         * @summary Create a new passing in Orbita
         * @param {string} portId Id of relevant port
         * @param {OrbitaPassingRequest} orbitaPassingRequest Payload to create a new passing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPassing(portId: string, orbitaPassingRequest: OrbitaPassingRequest, options?: any): AxiosPromise<OrbitaPassingRequest> {
            return localVarFp.createPassing(portId, orbitaPassingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Show latest passings
         * @summary Show latest passings
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPassings(portId: string, options?: any): AxiosPromise<PassingsResponse> {
            return localVarFp.getPassings(portId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PassingsApi - object-oriented interface
 * @export
 * @class PassingsApi
 * @extends {BaseAPI}
 */
export class PassingsApi extends BaseAPI {
    /**
     * Create a new passing in Orbita
     * @summary Create a new passing in Orbita
     * @param {string} portId Id of relevant port
     * @param {OrbitaPassingRequest} orbitaPassingRequest Payload to create a new passing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassingsApi
     */
    public createPassing(portId: string, orbitaPassingRequest: OrbitaPassingRequest, options?: RawAxiosRequestConfig) {
        return PassingsApiFp(this.configuration).createPassing(portId, orbitaPassingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show latest passings
     * @summary Show latest passings
     * @param {string} portId Id of relevant port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PassingsApi
     */
    public getPassings(portId: string, options?: RawAxiosRequestConfig) {
        return PassingsApiFp(this.configuration).getPassings(portId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermitsApi - axios parameter creator
 * @export
 */
export const PermitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @summary Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @param {string} portId Id of relevant port
         * @param {string} [startTime] Start time for the permit
         * @param {string} [target] Contract id, used if the visiting target is a company with a contract with the port
         * @param {string} [purpose] Purpose id for the selected purpose of the visit
         * @param {string} [facility] facility id / area id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxDuration: async (portId: string, startTime?: string, target?: string, purpose?: string, facility?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('getMaxDuration', 'portId', portId)
            const localVarPath = `/ports/{portId}/permits2/max-duration`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (target !== undefined) {
                localVarQueryParameter['target'] = target;
            }

            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }

            if (facility !== undefined) {
                localVarQueryParameter['facility'] = facility;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermitsApi - functional programming interface
 * @export
 */
export const PermitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @summary Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @param {string} portId Id of relevant port
         * @param {string} [startTime] Start time for the permit
         * @param {string} [target] Contract id, used if the visiting target is a company with a contract with the port
         * @param {string} [purpose] Purpose id for the selected purpose of the visit
         * @param {string} [facility] facility id / area id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaxDuration(portId: string, startTime?: string, target?: string, purpose?: string, facility?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaxDurationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaxDuration(portId, startTime, target, purpose, facility, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermitsApi.getMaxDuration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermitsApi - factory interface
 * @export
 */
export const PermitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermitsApiFp(configuration)
    return {
        /**
         * Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @summary Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
         * @param {string} portId Id of relevant port
         * @param {string} [startTime] Start time for the permit
         * @param {string} [target] Contract id, used if the visiting target is a company with a contract with the port
         * @param {string} [purpose] Purpose id for the selected purpose of the visit
         * @param {string} [facility] facility id / area id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxDuration(portId: string, startTime?: string, target?: string, purpose?: string, facility?: string, options?: any): AxiosPromise<Array<MaxDurationResponse>> {
            return localVarFp.getMaxDuration(portId, startTime, target, purpose, facility, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermitsApi - object-oriented interface
 * @export
 * @class PermitsApi
 * @extends {BaseAPI}
 */
export class PermitsApi extends BaseAPI {
    /**
     * Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
     * @summary Returns maximum duration and preferred duration for the permit, given start time, prupose, visiting target and facility
     * @param {string} portId Id of relevant port
     * @param {string} [startTime] Start time for the permit
     * @param {string} [target] Contract id, used if the visiting target is a company with a contract with the port
     * @param {string} [purpose] Purpose id for the selected purpose of the visit
     * @param {string} [facility] facility id / area id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitsApi
     */
    public getMaxDuration(portId: string, startTime?: string, target?: string, purpose?: string, facility?: string, options?: RawAxiosRequestConfig) {
        return PermitsApiFp(this.configuration).getMaxDuration(portId, startTime, target, purpose, facility, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortApi - axios parameter creator
 * @export
 */
export const PortApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Show port details
         * @summary Show details for current port. The details contains the following: Port id, name, reference, areas, checkpoints, purposes, port companies, security check results, security confirmations, integrations. All of this should be used to create a visitor application
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortDetails: async (portId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('getPortDetails', 'portId', portId)
            const localVarPath = `/ports/{portId}`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a document with the port as owner. The document will be available for all port administrators
         * @summary Upload a document with the port as owner. The document will be available for all port administrators
         * @param {string} portId Id of relevant port
         * @param {string} [category] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (portId: string, category?: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('uploadFile', 'portId', portId)
            const localVarPath = `/ports/{portId}/files`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (category !== undefined) { 
                localVarFormParams.append('category', category as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortApi - functional programming interface
 * @export
 */
export const PortApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortApiAxiosParamCreator(configuration)
    return {
        /**
         * Show port details
         * @summary Show details for current port. The details contains the following: Port id, name, reference, areas, checkpoints, purposes, port companies, security check results, security confirmations, integrations. All of this should be used to create a visitor application
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortDetails(portId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortDetails(portId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortApi.getPortDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a document with the port as owner. The document will be available for all port administrators
         * @summary Upload a document with the port as owner. The document will be available for all port administrators
         * @param {string} portId Id of relevant port
         * @param {string} [category] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(portId: string, category?: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(portId, category, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortApi.uploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortApi - factory interface
 * @export
 */
export const PortApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortApiFp(configuration)
    return {
        /**
         * Show port details
         * @summary Show details for current port. The details contains the following: Port id, name, reference, areas, checkpoints, purposes, port companies, security check results, security confirmations, integrations. All of this should be used to create a visitor application
         * @param {string} portId Id of relevant port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortDetails(portId: string, options?: any): AxiosPromise<PortDetails> {
            return localVarFp.getPortDetails(portId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a document with the port as owner. The document will be available for all port administrators
         * @summary Upload a document with the port as owner. The document will be available for all port administrators
         * @param {string} portId Id of relevant port
         * @param {string} [category] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(portId: string, category?: string, file?: File, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.uploadFile(portId, category, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortApi - object-oriented interface
 * @export
 * @class PortApi
 * @extends {BaseAPI}
 */
export class PortApi extends BaseAPI {
    /**
     * Show port details
     * @summary Show details for current port. The details contains the following: Port id, name, reference, areas, checkpoints, purposes, port companies, security check results, security confirmations, integrations. All of this should be used to create a visitor application
     * @param {string} portId Id of relevant port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortApi
     */
    public getPortDetails(portId: string, options?: RawAxiosRequestConfig) {
        return PortApiFp(this.configuration).getPortDetails(portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a document with the port as owner. The document will be available for all port administrators
     * @summary Upload a document with the port as owner. The document will be available for all port administrators
     * @param {string} portId Id of relevant port
     * @param {string} [category] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortApi
     */
    public uploadFile(portId: string, category?: string, file?: File, options?: RawAxiosRequestConfig) {
        return PortApiFp(this.configuration).uploadFile(portId, category, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VehicleApi - axios parameter creator
 * @export
 */
export const VehicleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns whether the vehicle is approved for access to the port
         * @summary Returns whether the vehicle is approved for access to the port
         * @param {string} portId Id of relevant port
         * @param {string} [licencePlate] Licence plate of the vehicle
         * @param {string} [facility] Facility id / area id
         * @param {string} [validTime] Timestamp to check if the vehicle is valid for. If null, results are given as if validTime &#x3D; now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVehicle: async (portId: string, licencePlate?: string, facility?: string, validTime?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('verifyVehicle', 'portId', portId)
            const localVarPath = `/ports/{portId}/vehicles/verify`
                .replace(`{${"portId"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (licencePlate !== undefined) {
                localVarQueryParameter['licencePlate'] = licencePlate;
            }

            if (facility !== undefined) {
                localVarQueryParameter['facility'] = facility;
            }

            if (validTime !== undefined) {
                localVarQueryParameter['validTime'] = (validTime as any instanceof Date) ?
                    (validTime as any).toISOString() :
                    validTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleApi - functional programming interface
 * @export
 */
export const VehicleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehicleApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns whether the vehicle is approved for access to the port
         * @summary Returns whether the vehicle is approved for access to the port
         * @param {string} portId Id of relevant port
         * @param {string} [licencePlate] Licence plate of the vehicle
         * @param {string} [facility] Facility id / area id
         * @param {string} [validTime] Timestamp to check if the vehicle is valid for. If null, results are given as if validTime &#x3D; now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyVehicle(portId: string, licencePlate?: string, facility?: string, validTime?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyVehicleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVehicle(portId, licencePlate, facility, validTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleApi.verifyVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VehicleApi - factory interface
 * @export
 */
export const VehicleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehicleApiFp(configuration)
    return {
        /**
         * Returns whether the vehicle is approved for access to the port
         * @summary Returns whether the vehicle is approved for access to the port
         * @param {string} portId Id of relevant port
         * @param {string} [licencePlate] Licence plate of the vehicle
         * @param {string} [facility] Facility id / area id
         * @param {string} [validTime] Timestamp to check if the vehicle is valid for. If null, results are given as if validTime &#x3D; now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVehicle(portId: string, licencePlate?: string, facility?: string, validTime?: string, options?: any): AxiosPromise<VerifyVehicleResponse> {
            return localVarFp.verifyVehicle(portId, licencePlate, facility, validTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehicleApi - object-oriented interface
 * @export
 * @class VehicleApi
 * @extends {BaseAPI}
 */
export class VehicleApi extends BaseAPI {
    /**
     * Returns whether the vehicle is approved for access to the port
     * @summary Returns whether the vehicle is approved for access to the port
     * @param {string} portId Id of relevant port
     * @param {string} [licencePlate] Licence plate of the vehicle
     * @param {string} [facility] Facility id / area id
     * @param {string} [validTime] Timestamp to check if the vehicle is valid for. If null, results are given as if validTime &#x3D; now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleApi
     */
    public verifyVehicle(portId: string, licencePlate?: string, facility?: string, validTime?: string, options?: RawAxiosRequestConfig) {
        return VehicleApiFp(this.configuration).verifyVehicle(portId, licencePlate, facility, validTime, options).then((request) => request(this.axios, this.basePath));
    }
}



